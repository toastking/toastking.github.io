{"data":{"markdownRemark":{"html":"<p>The Chrome Extensions API’s have surprisingly good documentation, but there’s no real “recipes” section. They give you all the parts you need then say “go have fun”. So this post will go through some of the rough edges I ran into when I started working on a Chrome extension.</p>\n<p>For security, Chrome heavily sandboxes all its extension code. You use <strong>messages</strong> to communicate with disparate pieces of code.  Chrome extension api’s are also event based, such as browser actions or  devtools</p>\n<p>There’s two main types of Chrome scripts, <a href=\"https://developer.chrome.com/extensions/content_scripts\">content scripts</a> and <a href=\"https://developer.chrome.com/extensions/background_pages#manifest\">background scripts</a>. <em>Background scripts</em> run based on listening to events. <em>Content scripts</em> are injected in to the web page but they can listen to messages from the background scripts. This is how you can trigger DOM changes from an extension.</p>\n<h2>How Do Chrome Extensions interface with the DOM?</h2>\n<p>The content scripts usually hold code to communicate with local storage and the DOM.\nOne of the things that confused me when I started working with Chrome API’s was how content scripts are run. Unlike background scripts, content scripts can either be injected programmatically or by declaring something in the <em>manifest</em> so it runs on certain urls. </p>\n<p>The other slightly confusing thing about content scripts is they are injected but not removed when you inject the script again. That means if you want to have a background script trigger a DOM event over and over you should inject the script <em>once</em> and then add code to listen for messages from the background script.</p>\n<p>In your <em>content script</em> call <code class=\"language-text\">chrome.runtime.onMessage.addListener</code> to listen for events from you background script. That way the extension injects the script into the DOM once and then will run whatever code is inside the listener whenever the background script fires off that message.</p>\n<h2>How can I debug the different scripts?</h2>\n<p>Chrome has support for the javascript <code class=\"language-text\">debugger;</code> statement. You can use that to programmatically put down breakpoints in the different files. <em>Content Scripts</em> can be debugged using the devtools on the current page.</p>\n<p><em>Background scripts</em> are a bit trickier because they’re not on the DOM.  You can access the devtools for a background script by going to <code class=\"language-text\">chrome://extensions</code> and then clicking on the <em>Background Page</em> link for you Chrome extension. This assumes you <a href=\"https://developer.chrome.com/extensions/getstarted\">loaded it as an unpacked extension</a>. </p>\n<h2>How do HAR Files work?</h2>\n<p>Chrome’s network panel uses<a href=\"https://en.wikipedia.org/wiki/.har\">HTTP Archive files</a>to display network information. This is how you can timing information for different network requests in your background scripts. You can use the <a href=\"https://developer.chrome.com/extensions/devtools_network\">chrome network apis</a>to get various HAR information. This is how I was able to get timing information for API calls.</p>","frontmatter":{"title":"Hitchhiker’s Guide to Chrome Extension Development","date":"January 14, 2019"}}},"pageContext":{"slug":"/Chrome-Extensions/Hitchhikers-Guide-To-Chrome/"}}